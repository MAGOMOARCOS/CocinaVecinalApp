name: Codex Agent

on:
  issue_comment:
    types: [created]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: codex-agent-${{ github.ref }}
  cancel-in-progress: true

jobs:
  codex:
    # 1) Solo en PRs
    # 2) Solo si el comentario contiene @codex
    # 3) Ignora bots (vercel[bot], github-actions[bot], etc.)
    if: >
      github.event_name == 'workflow_dispatch' ||
      (
        github.event.issue.pull_request &&
        contains(github.event.comment.body, '@codex') &&
        github.event.sender.type != 'Bot'
      )

    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR info
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // workflow_dispatch no trae issue/PR, así que solo soportamos comment-driven en PR
            if (context.eventName === 'workflow_dispatch') {
              core.setFailed('Este workflow está pensado para ejecutarse desde un comentario @codex en un PR.');
              return;
            }

            const prNumber = context.payload.issue.number;
            const { owner, repo } = context.repo;

            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

            core.setOutput('number', String(pr.data.number));
            core.setOutput('head_ref', pr.data.head.ref);
            core.setOutput('head_sha', pr.data.head.sha);
            core.setOutput('base_ref', pr.data.base.ref);

            // Guardamos el comentario completo para construir el prompt
            core.setOutput('comment_body', context.payload.comment.body);

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr.outputs.head_ref }}
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install deps
        run: npm ci

      - name: Build prompt file
        run: |
          mkdir -p .codex
          node - <<'NODE'
          const fs = require('fs');

          const comment = process.env.COMMENT_BODY || '';
          // Quitamos el primer "@codex" para quedarnos con la orden
          const cleaned = comment.replace(/@codex\s*/i, '').trim();

          let kickoff = '';
          if (fs.existsSync('.codex-kickoff')) {
            kickoff = fs.readFileSync('.codex-kickoff', 'utf8');
          }

          const prompt =
`Eres un agente de PR que MODIFICA el repo con cambios mínimos y deja \`npm run build\` en verde.

REGLAS:
- Cambios mínimos, sin reescribir toda la app.
- Si falta un módulo importado (p.ej. @/lib/types), créalo con una implementación/tipos tolerantes.
- No expongas secretos ni uses la OPENAI_API_KEY en código de frontend.
- Al final, devuelve un UNIFIED DIFF aplicable con \`git apply\`.

CONTEXTO (.codex-kickoff):
${kickoff}

ORDEN DEL USUARIO (comentario PR):
${cleaned}
`;
          fs.writeFileSync('.codex/prompt.txt', prompt);
          NODE
        env:
          COMMENT_BODY: ${{ steps.pr.outputs.comment_body }}

      - name: Run Codex (produce patch)
        id: codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt-file: .codex/prompt.txt
          # Le forzamos a devolver JSON con patch + summary
          output-schema: |
            {
              "type": "object",
              "properties": {
                "summary": { "type": "string" },
                "patch": { "type": "string" }
              },
              "required": ["summary", "patch"],
              "additionalProperties": false
            }

      - name: Apply patch
        id: apply
        run: |
          node - <<'NODE'
          const fs = require('fs');

          const raw = process.env.CODEX_FINAL || '';
          let data;
          try {
            data = JSON.parse(raw);
          } catch (e) {
            console.error('No pude parsear JSON de Codex. Raw:\n', raw);
            process.exit(1);
          }

          const patch = (data.patch || '').trim();
          const summary = (data.summary || '').trim();

          fs.writeFileSync('.codex/summary.txt', summary || '(sin resumen)');
          fs.writeFileSync('.codex/patch.diff', patch + '\n');

          if (!patch) {
            console.error('Patch vacío: nada que aplicar.');
            process.exit(1);
          }
          NODE
        env:
          CODEX_FINAL: ${{ steps.codex.outputs.final-message }}

      - name: Git apply
        run: git apply --whitespace=fix .codex/patch.diff

      - name: Build
        run: npm run build

      - name: Commit & push changes
        run: |
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit."
            exit 0
          fi
          git config user.name "codex-bot"
          git config user.email "codex-bot@users.noreply.github.com"
          git add -A
          git commit -m "chore: codex fixes"
          git push origin HEAD:${{ steps.pr.outputs.head_ref }}

      - name: Comment back on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('.codex/summary.txt', 'utf8');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.pr.outputs.number }}'),
              body: `✅ He aplicado cambios y pasado \`npm run build\`.\n\n**Resumen:**\n${summary}`
            });
