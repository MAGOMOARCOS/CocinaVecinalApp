name: Agent (PR-driven)

on:
  # Automático: cuando tú actualices el plan de trabajo (sin tocar código)
  push:
    branches: [main]
    paths:
      - "AGENT_TASKS.md"

  # Manual: por si quieres forzar una ejecución con una instrucción puntual
  workflow_dispatch:
    inputs:
      instruction:
        description: "Instrucción extra (opcional)"
        required: false
        default: ""

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: agent-pr-driven-main
  cancel-in-progress: false

jobs:
  agent:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Memoria simple entre ejecuciones (evita repetir errores caros)
      - name: Restore agent state cache
        uses: actions/cache@v4
        with:
          path: .agent/state.json
          key: agent-state-main
          restore-keys: |
            agent-state-

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install deps
        run: npm ci

      - name: Run agent (plan -> changes -> build -> PR -> comment)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          INSTRUCTION: ${{ inputs.instruction }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # 1) Rama de trabajo
          BRANCH="agent/run-${GITHUB_RUN_ID}"
          git checkout -b "$BRANCH"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # 2) Ejecutar agente (con memoria + protección anti-errores repetidos)
          python3 - <<'PY'
          import os, json, sys, pathlib, urllib.request, urllib.error, subprocess, datetime

          # ---------- helpers ----------
          def now_iso():
              return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

          def read_text(path):
              try:
                  return pathlib.Path(path).read_text(encoding="utf-8")
              except FileNotFoundError:
                  return ""

          def write_text(path, content):
              p = pathlib.Path(path)
              p.parent.mkdir(parents=True, exist_ok=True)
              p.write_text(content, encoding="utf-8")

          def safe_exit(msg, code=1):
              print(msg, file=sys.stderr)
              sys.exit(code)

          # ---------- load state (cached) ----------
          state_path = pathlib.Path(".agent/state.json")
          state = {}
          if state_path.exists():
              try:
                  state = json.loads(state_path.read_text(encoding="utf-8"))
              except Exception:
                  state = {}

          state.setdefault("runs_total", 0)
          state.setdefault("runs_today", 0)
          state.setdefault("last_run_date", "")
          state.setdefault("last_error", "")
          state.setdefault("same_error_streak", 0)
          state.setdefault("openai_calls_total", 0)

          # Reset daily counter
          today = datetime.date.today().isoformat()
          if state.get("last_run_date") != today:
              state["runs_today"] = 0
              state["same_error_streak"] = 0
              state["last_run_date"] = today

          state["runs_total"] += 1
          state["runs_today"] += 1

          # Si se repite el MISMO error 2 veces seguidas, paramos para no gastar.
          if state.get("same_error_streak", 0) >= 2 and state.get("last_error"):
              safe_exit(f"STOP: mismo error repetido 2 veces ({state['last_error']}). Evito otra ejecución para no generar más coste.", 2)

          # ---------- input ----------
          api_key = (os.environ.get("OPENAI_API_KEY") or "").strip()
          if not api_key:
              state["last_error"] = "MISSING_OPENAI_API_KEY"
              state["same_error_streak"] = state.get("same_error_streak", 0) + 1
              write_text(state_path, json.dumps(state, indent=2))
              safe_exit("ERROR: Falta el secret OPENAI_API_KEY en GitHub.", 2)

          extra_instruction = (os.environ.get("INSTRUCTION") or "").strip()

          agent_tasks = read_text("AGENT_TASKS.md").strip()
          if not agent_tasks:
              state["last_error"] = "MISSING_AGENT_TASKS"
              state["same_error_streak"] = state.get("same_error_streak", 0) + 1
              write_text(state_path, json.dumps(state, indent=2))
              safe_exit("ERROR: AGENT_TASKS.md está vacío o no existe.", 2)

          # ---------- scope rules ----------
          ALLOW_PREFIXES = ("app/", "components/")
          DENY_PREFIXES = (".github/",)
          DENY_EXACT = ("AGENT_TASKS.md",)

          # ---------- provide real context to avoid hallucinations ----------
          context_files = [
              "app/layout.tsx",
              "app/page.tsx",
              "app/globals.css",
              "components/Header.tsx",
              "components/Footer.tsx",
          ]
          current_files = {p: read_text(p) for p in context_files}

          try:
              file_list = subprocess.check_output(["git", "ls-files"], text=True)
          except Exception:
              file_list = ""

          # ---------- prompt ----------
          system = (
              "Eres un agente de ingeniería de software para un repo Next.js (App Router).\n"
              "Devuelve EXCLUSIVAMENTE un JSON válido (sin markdown) con este formato:\n"
              "{\n"
              '  \"files\": {\n'
              '    \"ruta/archivo.tsx\": \"CONTENIDO COMPLETO DEL ARCHIVO\",\n'
              '    \"ruta/otro.css\": \"CONTENIDO COMPLETO\"\n'
              "  }\n"
              "}\n\n"
              "Reglas estrictas:\n"
              "- Devuelve ARCHIVOS COMPLETOS, no diff.\n"
              "- Cambios mínimos para cumplir Phase 1 definida en AGENT_TASKS.md.\n"
              "- No rompas el build: debe pasar `npm run build`.\n"
              "- Prohibido modificar .github/ y AGENT_TASKS.md.\n"
              "- Solo puedes crear/modificar rutas bajo app/ y components/.\n"
              "- Si no hace falta cambiar nada, devuelve {\"files\":{}}.\n"
          )

          user = {
              "repo_file_list": file_list,
              "agent_tasks_md": agent_tasks,
              "extra_instruction": extra_instruction if extra_instruction else "(none)",
              "current_files": current_files,
              "scope": {
                  "allowed_prefixes": list(ALLOW_PREFIXES),
                  "denied_prefixes": list(DENY_PREFIXES),
                  "denied_exact": list(DENY_EXACT),
              },
          }

          payload = {
              "model": "gpt-4o-mini",
              "input": [
                  {"role": "system", "content": [{"type": "input_text", "text": system}]},
                  {"role": "user", "content": [{"type": "input_text", "text": json.dumps(user)}]},
              ],
          }

          # ---------- call OpenAI ----------
          req = urllib.request.Request(
              "https://api.openai.com/v1/responses",
              data=json.dumps(payload).encode("utf-8"),
              headers={
                  "Authorization": f"Bearer {api_key}",
                  "Content-Type": "application/json",
              },
              method="POST",
          )

          state["openai_calls_total"] += 1

          try:
              with urllib.request.urlopen(req) as r:
                  data = json.loads(r.read().decode("utf-8"))
          except urllib.error.HTTPError as e:
              body = ""
              try:
                  body = e.read().decode("utf-8")
              except Exception:
                  body = "<could not read error body>"
              state["last_error"] = f"OPENAI_HTTP_{e.code}"
              state["same_error_streak"] = state.get("same_error_streak", 0) + 1
              write_text(state_path, json.dumps(state, indent=2))
              print("OPENAI_ERROR_BODY_BEGIN", file=sys.stderr)
              print(body, file=sys.stderr)
              print("OPENAI_ERROR_BODY_END", file=sys.stderr)
              safe_exit(f"ERROR: OpenAI HTTP {e.code} {e.reason}", 1)

          # ---------- extract output text ----------
          text = ""
          for item in data.get("output", []):
              if item.get("type") == "message":
                  for c in item.get("content", []):
                      if c.get("type") == "output_text":
                          text += c.get("text", "")
          text = text.strip()

          try:
              result = json.loads(text) if text else {"files": {}}
          except json.JSONDecodeError:
              state["last_error"] = "MODEL_INVALID_JSON"
              state["same_error_streak"] = state.get("same_error_streak", 0) + 1
              write_text(state_path, json.dumps(state, indent=2))
              print("MODEL_OUTPUT_BEGIN", file=sys.stderr)
              print(text, file=sys.stderr)
              print("MODEL_OUTPUT_END", file=sys.stderr)
              safe_exit("ERROR: El modelo no devolvió JSON válido.", 1)

          files = result.get("files", {})
          if not isinstance(files, dict):
              state["last_error"] = "MODEL_BAD_SCHEMA"
              state["same_error_streak"] = state.get("same_error_streak", 0) + 1
              write_text(state_path, json.dumps(state, indent=2))
              safe_exit("ERROR: El JSON debe contener un objeto 'files'.", 1)

          # ---------- enforce path rules ----------
          for path in files.keys():
              if path in DENY_EXACT:
                  safe_exit(f"ERROR: Ruta prohibida en output: {path}", 1)
              if path.startswith(DENY_PREFIXES):
                  safe_exit(f"ERROR: Prefijo prohibido en output: {path}", 1)
              if not path.startswith(ALLOW_PREFIXES):
                  safe_exit(f"ERROR: Ruta fuera de alcance (solo app/ y components/): {path}", 1)

          # ---------- write files ----------
          for path, content in files.items():
              write_text(path, content)

          # Guardar estado “OK”
          state["last_error"] = ""
          state["same_error_streak"] = 0
          state["last_run_at"] = now_iso()
          state["last_written_files"] = sorted(list(files.keys()))
          write_text(state_path, json.dumps(state, indent=2))

          print("WROTE_FILES:", ", ".join(sorted(files.keys())) if files else "(none)")
          PY

          # 3) Build gate: si no compila, no hay PR
          npm run build

          # 4) PR + comentario resumen (esto es tu “entrega” automática)
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "agent: Phase 1 changes"
            git push -u origin "$BRANCH"

            PR_URL="$(gh pr create \
              --title "Agent: Phase 1 (AGENT_TASKS.md)" \
              --body "PR generado automáticamente por el agente. Build verificado." \
              --base main \
              --head "$BRANCH" \
              --json url \
              --jq .url)"

            # Resumen (muy útil para que “me deje el resultado”)
            WROTE="$(python3 -c "import json;print(', '.join(json.load(open('.agent/state.json')).get('last_written_files', [])) or '(none)')")"
            RUNS_TODAY="$(python3 -c "import json;print(json.load(open('.agent/state.json')).get('runs_today', 0))")"
            CALLS_TOTAL="$(python3 -c "import json;print(json.load(open('.agent/state.json')).get('openai_calls_total', 0))")"

            BODY=$(cat <<'EOF'
✅ **Agent run completed**
- **Branch:** `$BRANCH`
- **Build:** PASS (`npm run build`)
- **Files written:** $WROTE
- **Runs today:** $RUNS_TODAY
- **OpenAI calls total (agent memory):** $CALLS_TOTAL
EOF
            )

            gh pr comment "$PR_URL" --body "$BODY"

            echo "PR created: $PR_URL"
          else
            echo "No changes"
          fi

      - name: Save agent state cache
        if: always()
        uses: actions/cache@v4
        with:
          path: .agent/state.json
          key: agent-state-main
